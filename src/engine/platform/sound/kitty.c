/***************************************************************************
    kitty register layout:
    ========================
    
    Hardware Details:
    
    3 Tone Channels, 1 Percussion Channel
    
    A 82C54 timer is used to control the frequency of the first 3 Tone Channels,
    Channel 4 uses a seperate fixed frequency timer (8*50hz), generated by the
    video circuit
    
    Each channel waveform is stored in a 8bit self feeding shift register (4*x165)
    Each channel has a 4bit volume control for both left and right (2*x670)
    
    Extra logic includes a 4-to-1 multiplexer (x153) and a latch to buffer the
    sound output to the dac (x574)
    
    All register are WRITE-ONLY

    offs | 7654 3210 | description
    -----+-----------+---------------------------
    0x00 | ffff ffff | Channel 1 Frequency (82c54)
    0x01 | ffff ffff | Channel 2 Frequency (82c54)
    0x02 | ffff ffff | Channel 3 Frequency (82c54)
    0x03 | ccff mmmd | Frequency Control   (82c54)
                     | c = register select (0-3)
                     | f = format (latch value, lo byte, hi byte, lo+hi byte)
                     | m = mode (010 only)
                     | d = decimal (off, on)
    0x10 | llll rrrr | Channel 1 Volume (left/right)
    0x11 | llll rrrr | Channel 2 Volume (left/right)
    0x12 | llll rrrr | Channel 3 Volume (left/right)
    0x13 | llll rrrr | Channel 4 Volume (left/right)
    0x14 | wwww wwww | Channel 1 Waveform
    0x15 | wwww wwww | Channel 2 Waveform
    0x16 | wwww wwww | Channel 3 Waveform
    0x17 | wwww wwww | Channel 4 Waveform

***************************************************************************/

#include "kitty.h"

uint8_t kitty_psg_tick_wave(uint8_t wave) {
    int lowest_bit = wave & 0x01;
    wave = (wave >> 1) + (lowest_bit << 7);
    return wave;
}

// psg noise ticking is handled externally
uint8_t kitty_psg_tick_noise(kitty_psg *psg) {
    psg->wave[3] = kitty_psg_tick_wave(psg->wave[3]);
}

uint8_t kitty_psg_tick_82c54(kitty_psg *psg) {
    for (int i = 0; i < 3; i++) {
        int bdc  = psg->timer_control[i] & 0x01;
        int mode = (psg->timer_control[i] & 0x06) >> 1;
        int rw   = (psg->timer_control[i] & 0x30) >> 4;
        int out  = psg->timer_output[i];
        
        switch (mode) {
        case 0:
            psg->timer_count[i] -= 1;
            if (psg->timer_count[i] == 0) psg->timer_output[i] = 1;
        break;
        case 1:
            psg->timer_output[i] = 1;
        break;
        case 6:
        case 2:
            psg->timer_count[i] -= 1;
            if (psg->timer_count[i] == 0) {
                psg->timer_output[i] = 1;
                psg->timer_count[i] = psg->timer_reload[i];
            } else {
                psg->timer_output[i] = 0;
            }
        break;
        case 7:
        case 3:
            psg->timer_count[i] -= 1;
            if (psg->timer_count[i] == 0) {
                psg->timer_output[i] = 1;
                psg->timer_count[i] = psg->timer_reload[i];
            } else {
                psg->timer_output[i] = 0;
                if (psg->timer_count[i] < psg->timer_reload[i]/2) {
                    psg->timer_output[i] = 0;
                }
            }
        break;
        case 4:
            break;
        case 5:
            break;
        }
        if (out == 0 && psg->timer_output[i] == 1) {
            psg->wave[i] = kitty_psg_tick_wave(psg->wave[i]);
        }
    }
}

uint8_t kitty_psg_write(kitty_psg *psg, uint16_t address, uint8_t value) {
    address = address & 0x1F;
    uint8_t sub_address = address;
    
    switch (address >> 4) {
        case 0:
            sub_address = address & 0x03;
            // 82c54 (frequency)

            if (sub_address == 3) {
                uint8_t target = value >> 6;
                psg->timer_control[target] = value;
                psg->timer_state[target] = 0;
            } else {
                int rw   = (psg->timer_control[sub_address] & 0x30) >> 4;
                switch (rw) {
                    case 1:
                        // low only
                        if (psg->timer_state[sub_address] == 0) {
                            psg->timer_state[sub_address] = 1;
                            psg->timer_reload[sub_address] = (psg->timer_reload[sub_address] & 0xFF00) + value;
                        }
                        break;
                    case 2:
                        // hi only
                        if (psg->timer_state[sub_address] == 0) {
                            psg->timer_state[sub_address] = 1;
                            psg->timer_reload[sub_address] = (psg->timer_reload[sub_address] & 0x00FF) + (value<<8);
                        }
                        break;
                    case 3:
                        // lo then hi
                        if (psg->timer_state[sub_address] == 0) {
                            psg->timer_state[sub_address] = 1;
                            psg->timer_reload[sub_address] = (psg->timer_reload[sub_address] & 0xFF00) + value;
                        }
                        else if (psg->timer_state[sub_address] == 1) {
                            psg->timer_state[sub_address] = 2;
                            psg->timer_reload[sub_address] = (psg->timer_reload[sub_address] & 0x00FF) + (value<<8);
                        }
                        break;
                   default:
                        break;
                }
            }
            break;
        case 1:
            // Volume and Wave
            sub_address = address & 0x07;
            if (sub_address < 4) {
                psg->volume[sub_address] = value;
            } else {
                sub_address -= 4;
                psg->wave[sub_address] = value;
            }
            break;
        default:
            break;
    }
}

int16_t kitty_psg_get_channel_sample(kitty_psg *psg, int left,int channel) {
    int16_t value = 0;
    if (psg->wave[channel] & 0x01) {
        if (left) {
            value += (psg->volume[channel]>>4);
        } else {
            value += (psg->volume[channel]&0x0F);
        }
    }
    
    return value;
}

int16_t kitty_psg_get_sample(kitty_psg *psg, int left) {
    int16_t value = 0;
    for (int i = 0; i < 4; i++) {
        if (psg->wave[i] & 0x01) {
            if (left) {
                value += (psg->volume[i]>>4);
            } else {
                value += (psg->volume[i]&0x0F);
            }
        }
    }
    return value;
}
